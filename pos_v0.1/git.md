# Git

## Repostory

### git clone
1. git clone remote-address [local-name]
2. 支持多种协议HTTP(s),SSH,git,file,ftp(s),rsync,Git协议下载速度最快，SSH协议用于需要用户认证的场合

### git remote
1. git clone -o host-name remote-address
2. git remote show/rm host-name
3. git remote add new-host-name address
4. git remote rename old-host-name new-host-name


### git fetch
1. git fetch 取回所有分支的更新
2. git fetch remote-host-name branch-name 取回特定分支

### git pull
1. git pull 取回分支并合并
2. git pull remote-host-name remote-branch-name:local-branch-name 取回远程主机上的特定分支与本地分支合并，若未指定，默认当前分支
3. git pull origin next 等价于 git fetch origin; git merge orgin/next
4. git branch --set-upstram master origin/next 指定master分支追踪origin/next分支，如果当前分支与远程分支存在追踪关系，git pull可以省略远程分支名，如果当前分支只有一个追踪分支，可以省略主机名

### git push
1. git push remote-host local-branch-name:remote-branch
2. 如果省略远程分支名，表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。
3. 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master等价于git push origin --delete master
4. 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 git push origin
5. 如果当前分支只有一个追踪分支，那么主机名都可以省略。git push
6. 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。git push -u origin master
7. 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机。git pull --all origin
8. 强制推送 git push --force origin (not recommend)
9. git push不会推送标签（tag），除非使用–tags选项 git push origin --tags

### git diff
1. git diff 查看尚未暂存的文件更新了哪些部分,此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。
2. git diff --cached/staged 已经暂存起来的文件和上次提交时的快照之间的差异

### git log
1. git log 按提交时间列出所有的更新，最近的更新排在最上面,-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新
2. git log --stat 显示简要的增改行数统计
3. git log --pretty=oneline 每个提交放在一行显示
4. git log --pretty=format:"%h - %an, %ar : %s" 定制要显示的记录格式，这样的输出便于后期编程提取分析
5. git log --pretty=format:"%h %s" --graph 可以看到开头多出一些 ASCII 字符串表示的简单图形,形象地展示了每个提交所在的分支及其分化衍合情况

### git branch
1. Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针
2. Git 通过保存着一个名为 HEAD 的特别指针知道你当前在哪个分支上工作。

### git merge
1. 顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。
2. Git 会用两个分支的末端以及它们的共同祖先进行一次简单的三方合并计算。对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象,这个提交对象比较特殊，它有两个祖先.

### git rebase
1. 回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支）后续的历次提交对象，生成一系列文件补丁，然后以基底分支最后一个提交对象为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象，从而改写衍合提交对象的提交历史，使它成为 master 分支的直接下游

### 撤销操作
1. git commit --amend 修改最后一次提交(提交完成后发现少提交了，或者提交信息写错了)
2. git reset HEAD filename 取消已经暂存的文件
3. git checkout -- filename  取消对文件的修改
4.  

## 版本控制工具历史
1. 本地版本控制系统:如rcs,工作原理基本上就是保存并管理文件补丁,文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。
2. 集中化的版本控制系统CVCS:如CVS,Subversion,Perforce单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新(缺点：宕机时无法提交更新，没备份的话可能存在丢失数据的风险)
3. 分布式版本控制系统DVCS:Git,Mercurial,Bazaar,Darcs.客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来,如果某一处发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复

## Git基础
1. 直接记录快照，而非差异比较：Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。Git 并不保存这些前后变化的差异数据。Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。
2. 近乎所有操作都是本地执行：在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。
3. 时刻保持数据完整性：在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成
4. 多数操作仅添加数据
5. 文件的三种状态：已提交（committed），已修改（modified）和已暂存（staged）
6. 目录：每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果git clone --bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。
7. 基本流程：1. 在工作目录中修改某些文件。 2. 对修改后的文件进行快照，然后保存到暂存区域。 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。


### 初始化新仓库
1. git init
2. git clone
3. 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记 录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存 区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。

### git原理
1. 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。
2. 当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。